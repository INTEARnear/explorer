// TODO clean up this component, was fully generated by Claude
import React, { useEffect, useRef, useCallback, ReactNode } from 'react';

const GlitchText = ({ children, isLoading }: { children: ReactNode, isLoading: boolean }) => {
  const containerRef = useRef<any>(null);
  const svgRef = useRef<any>(null);
  const contentRef = useRef(null);

  const blackColor = '#000000';
  const tealColor = '#00ec97';
  const maxRects = 75;

  const createGlitchRect = useCallback((color: string) => {
    if (!containerRef.current) return null;
    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    const { width, height } = containerRef.current.getBoundingClientRect();
    rect.setAttribute('x', `${Math.random() * width}px`);
    rect.setAttribute('y', `${Math.random() * height}px`);
    rect.setAttribute('width', `${Math.random() * 170}px`);
    rect.setAttribute('height', `${Math.random() * 100}px`);
    rect.setAttribute('fill', color);
    rect.setAttribute('opacity', (Math.random() * 0.7 + 0.3).toString());
    return rect;
  }, []);

  const animateGlitch = useCallback((color: string) => {
    if (!svgRef.current) return;
    if (svgRef.current.childElementCount >= maxRects) {
      svgRef.current.removeChild(svgRef.current.firstElementChild);
    }
    const rect = createGlitchRect(color);
    if (rect) {
      svgRef.current.appendChild(rect);

      setTimeout(() => {
        if (svgRef.current && svgRef.current.contains(rect)) {
          svgRef.current.removeChild(rect);
        }
      }, Math.random() * 300 + 50);
    }
  }, [createGlitchRect]);

  useEffect(() => {
    let glitchInterval1: any, glitchInterval2: any, glitchInterval3: any, highlightInterval: any;

    const startGlitchIntervals = () => {
      glitchInterval1 = setInterval(() => animateGlitch(blackColor), 20);
      glitchInterval2 = setInterval(() => animateGlitch(tealColor), 40);
      glitchInterval3 = setInterval(() => {
        for (let i = 0; i < 10; i++) {
          setTimeout(() => {
            animateGlitch(blackColor);
            if (i % 2 === 0) {
              animateGlitch(tealColor);
            }
          }, i * 20);
        }
      }, 2000);
    };

    const stopGlitchIntervals = () => {
      clearInterval(glitchInterval1);
      clearInterval(glitchInterval2);
      clearInterval(glitchInterval3);
    };

    // Word-based random text highlighting
    const highlightedElements = new Set<Element>();

    const getAllTextNodes = (element: Element) => {
      const textNodes = [];
      const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);
      let node;
      while (node = walker.nextNode()) {
        if (node.nodeValue?.trim() !== '') {
          textNodes.push(node);
        }
      }
      return textNodes;
    };

    const addHighlight = () => {
      if (!contentRef.current) return;

      const allTextNodes = getAllTextNodes(contentRef.current);
      if (allTextNodes.length === 0) return;

      const randomTextNode = allTextNodes[Math.floor(Math.random() * allTextNodes.length)];
      const text = randomTextNode.nodeValue;
      const words = text?.split(/\s+/) ?? [];
      if (words.length === 0) return;

      const startWordIndex = Math.floor(Math.random() * words.length);
      const wordCount = Math.min(Math.floor(Math.random() * 3) + 1, words.length - startWordIndex);
      const endWordIndex = startWordIndex + wordCount;

      const startOffset = words.slice(0, startWordIndex).join(' ').length + (startWordIndex > 0 ? 1 : 0);
      const endOffset = words.slice(0, endWordIndex).join(' ').length;

      const range = document.createRange();
      range.setStart(randomTextNode, startOffset);
      range.setEnd(randomTextNode, endOffset);

      const highlightSpan = document.createElement('span');
      highlightSpan.className = 'highlight';
      range.surroundContents(highlightSpan);

      highlightedElements.add(highlightSpan);

      const duration = Math.random() * 700 + 100;
      setTimeout(() => {
        if (highlightSpan.parentNode) {
          highlightSpan.parentNode.replaceChild(document.createTextNode(highlightSpan.textContent ?? ""), highlightSpan);
          highlightedElements.delete(highlightSpan);
        }
      }, duration);
    };

    const runHighlight = () => {
      addHighlight();
      highlightInterval = setTimeout(runHighlight, Math.random() * 500 + 100);
    };

    if (isLoading) {
      startGlitchIntervals();
      runHighlight();
    } else {
      stopGlitchIntervals();
      clearTimeout(highlightInterval);
      if (svgRef.current) svgRef.current.innerHTML = '';
      highlightedElements.forEach(span => {
        if (span.parentNode) {
          span.parentNode.replaceChild(document.createTextNode(span.textContent ?? ''), span);
        }
      });
      highlightedElements.clear();
    }

    return () => {
      stopGlitchIntervals();
      clearTimeout(highlightInterval);
      if (svgRef.current) svgRef.current.innerHTML = '';
      highlightedElements.forEach(span => {
        if (span.parentNode) {
          span.parentNode.replaceChild(document.createTextNode(span.textContent ?? ''), span);
        }
      });
      highlightedElements.clear();
    };
  }, [isLoading, animateGlitch]);

  return (
    <div ref={containerRef} className="glitch-component" style={{ position: 'relative', overflow: 'hidden', backgroundColor: '#000000', color: '#00ec97', fontFamily: 'Arial, sans-serif', height: '100%', width: '100%' }}>
      <div className="content-container" style={{ position: 'relative', padding: '20px' }}>
        <div ref={contentRef} className="content">
          {children}
        </div>
      </div>
      <svg ref={svgRef} className="glitch-overlay" xmlns="http://www.w3.org/2000/svg" style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', pointerEvents: 'none', zIndex: 2, mixBlendMode: 'screen' }}>
        <defs>
          <filter id="noise">
            <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="4" stitchTiles="stitch" result="noise" />
            <feColorMatrix in="noise" type="saturate" values="0" />
          </filter>
        </defs>
        <rect width="100%" height="100%" filter="url(#noise)" opacity="0.07" />
      </svg>
      <style jsx>{`
        .highlight {
          background-color: #00ec97;
          color: #000000;
        }
      `}</style>
    </div>
  );
};

export default GlitchText;